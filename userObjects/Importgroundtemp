# Ground Temperature Calculator
# By Anton Szilasi with help from Chris Mackey
# ajszilasi@gmail.com
# Ladybug started by Mostapha Sadeghipour Roudsari is licensed
# under a Creative Commons Attribution-ShareAlike 3.0 Unported License.

"""
Use this component to calculate the hourly ground temperature at a specific depth.

-
Provided by Ladybug 0.0.58
    
    Args:
        _groundTemperatureData: ...
        _epwFile: An .epw file path on your system as a string
        visualisedata: Set to true to visualise data as a graph
    Returns:
        readMe!: ...
        groundtemp1st: In every epw file there are monthly ground temperatures at 3 different depths this is the 1st
        groundtemp2nd: In every epw file there are monthly ground temperatures at 3 different depths this is the 2nd
        groundtemp3rd: In every epw file there are monthly ground temperatures at 3 different depths this is the 3rd
        graphAxes , profileCrvs, graphdata, graphtext: All these combine to create graph outputs they dont need to be connected to any objects to work

"""
ghenv.Component.Name = "Ladybug_Import Ground Temp"
ghenv.Component.NickName = 'Importgroundtemp'
ghenv.Component.Message = 'VER 0.0.58\nNOV_30_2014'
ghenv.Component.Category = "Ladybug"
ghenv.Component.SubCategory = "0 | Ladybug"
#compatibleLBVersion = VER 0.0.58\nAUG_20_2014
try: ghenv.Component.AdditionalHelpFromDocStrings = "2"
except: pass


import scriptcontext as sc
import os
import itertools
from clr import AddReference
AddReference('Grasshopper')
import Grasshopper.Kernel as gh
import Rhino as rc

def main(_epw_file):
    # import the classes
    
    if sc.sticky.has_key('ladybug_release'):
        try:
            if not sc.sticky['ladybug_release'].isCompatible(ghenv.Component): return -1
        except:
            warning = "You need a newer version of Ladybug to use this compoent." + \
            "Use updateLadybug component to update userObjects.\n" + \
            "If you have already updated userObjects drag Ladybug_Ladybug component " + \
            "into canvas and try again."
            w = gh.GH_RuntimeMessageLevel.Warning
            ghenv.Component.AddRuntimeMessage(w, warning)
            return -1
        lb_preparation = sc.sticky["ladybug_Preparation"]()
        lb_visualization = sc.sticky["ladybug_ResultVisualization"]()
        
        if not os.path.isfile(_epw_file):
            warningM = "Failed to find the file: " + str(_epw_file)
            print warningM
            w = gh.GH_RuntimeMessageLevel.Warning
            ghenv.Component.AddRuntimeMessage(w, warningM)
            return -1
        locationData = lb_preparation.epwLocation(_epw_file)
        groundtemp = lb_preparation.groundTempData(_epw_file,locationData[0])
        
        
        return locationData, groundtemp, lb_visualization, lb_preparation
    
    else:
        warningM = "First please let the Ladybug fly..."
        print warningM
        w = gh.GH_RuntimeMessageLevel.Warning
        ghenv.Component.AddRuntimeMessage(w, warningM)
        return -1

# Collecting Data
if _epwFile and _epwFile.endswith('.epw') and  _epwFile != 'C:\Example.epw':
    result = main(_epwFile)
    if result!= -1:
        location, locName, latitude = result[0][-1], result[0][0], result[0][1]
        
        groundtemp1st,groundtemp2nd,groundtemp3rd = result[1][0],result[1][1],result[1][2]
        
        lb_visualization, lb_preparation = result[2], result[3]

        
elif _epwFile == 'C:\Example.epw': pass
else:
    print "Please connect a valid epw file address to _epw_file input..."
    w = gh.GH_RuntimeMessageLevel.Warning
    ghenv.Component.AddRuntimeMessage(w, "Please connect a valid epw file address to _epw_file input...")
    

if visualisedata == True:

    #Create a surface to represent the ground plane
    xyPlane = rc.Geometry.Plane.WorldXY
    rectangle = rc.Geometry.Rectangle3d(xyPlane, 10, 10)
    rectangleCurve = rectangle.ToNurbsCurve()

    rectangleBrep = rc.Geometry.Brep.CreatePlanarBreps(rectangleCurve)[0]

    #Create a line to represent the vertical axis.
    rectangleCenterPt = rc.Geometry.AreaMassProperties.Compute(rectangleBrep).Centroid
    rectangleDepthPt = rc.Geometry.Point3d(rectangleCenterPt.X, rectangleCenterPt.Y, rectangleCenterPt.Z-10)
    verticalAxis = rc.Geometry.LineCurve(rectangleCenterPt, rectangleDepthPt)

    #Create markings along this vertical axis every meter.
    divisionParams = rc.Geometry.Curve.DivideByLength(verticalAxis, 1, False)
    divisionPts = []
    for param in divisionParams:
        divisionPts.append(verticalAxis.PointAt(param))

    divisionLines = []
    for point in divisionPts:
        otherPt = rc.Geometry.Point3d(point.X+0.25, point.Y, point.Z)
        divisionLines.append(rc.Geometry.Line(point, otherPt))

    #Create a line that represents the horizontal axis.
    horizPt1 = rc.Geometry.Point3d(rectangleCenterPt.X+5, rectangleCenterPt.Y, rectangleCenterPt.Z)
    horizPt2 = rc.Geometry.Point3d(rectangleCenterPt.X-5, rectangleCenterPt.Y, rectangleCenterPt.Z)
    horizAxis = rc.Geometry.LineCurve(horizPt1, horizPt2) # Draw a line between these two points making the horizontail axis

    #Create markings along this horizontial axis every degree C.
    divisionParams1 = rc.Geometry.Curve.DivideByLength(horizAxis, 1, False)
    divisionPts1 = []
    for param in divisionParams1:
        divisionPts1.append(horizAxis.PointAt(param))
    

    divisionLines1 = []
    for point in divisionPts1:
        otherPt1 = rc.Geometry.Point3d(point.X, point.Y, point.Z+0.25)
        divisionLines1.append(rc.Geometry.Line(point, otherPt1))
        
     # Creating range of ground temp data to display on horizontial axis of graph
     
    groundtempall = groundtemp1st[8:] + groundtemp2nd[8:] + groundtemp3rd[8:]
    
    groundtempCtext = []
    
    c = (max(groundtempall)-min(groundtempall))/(len(divisionPts1)-1)
    
    groundtempCtext.append(min(groundtempall))
    
    tot = groundtempCtext[0]

    for i in range(len(divisionPts1)):
        tot += c
        groundtempCtext.append(tot)
        
    #Put all of these things into a list for the graphAxes output.
    graphAxes = [rectangleBrep, verticalAxis, horizAxis]
    graphAxes.extend(divisionLines) # Vertical lines
    graphAxes.extend(divisionLines1) # Horizontial lines 
    graphtext = []
    
    # For rotating text strings from yx plane to zx plane
    
    # Drawing the labels on the vertical axis
    
    graphtextvert = []
    
    for point in divisionPts: 
        
        textPlane = rc.Geometry.Plane(point, rc.Geometry.Vector3d(1,0,0),  rc.Geometry.Vector3d(0,0,1))
        textSrfs = lb_visualization.text2srf([str(point[2]) + ' m'], [point],'Verdana', 0.25, False, textPlane)
       
        for txt in textSrfs:
            graphtextvert.extend(txt)
            
    textPt = rc.Geometry.Point3d(4,4,4)
    textSrfs = lb_visualization.text2srf(['Depth below surface'], [textPt],'Verdana', 0.25, False, textPlane)
    for txt in textSrfs:
        graphAxes.extend(txt)
    
    # Drawing the labels on the horzontial axis
    
    graphtexthort = []
            
    for point,i in zip(divisionPts1,groundtempCtext):
        
        textPlane = rc.Geometry.Plane(point, rc.Geometry.Vector3d(1,1,1),  rc.Geometry.Vector3d(0,1,1))
        
        textSrfs = lb_visualization.text2srf([str(round(i,1)) + ' C'], [point],'Verdana', 0.25, False, textPlane) # Point should be groundtemp data
        
        for txt in textSrfs: # Adding text surfaces to graphtext so that they will be displayed 
            graphtexthort.extend(txt)
            
        for labels in graphtexthort:
            xtozxrotation = rc.Geometry.Transform.Translation(0,0,0)
            labels.Transform(xtozxrotation)
            
    textPt = rc.Geometry.Point3d(4,4,4)
    #textSrfs = lb_visualization.text2srf(['Temperature'], [textPt],'Verdana', 0.25, False, textPlane)
    for txt in textSrfs:
        graphAxes.extend(txt)
            
    graphtext = graphtexthort + graphtextvert 
            
    #Create a list of the depths that each list corresponds to.
    depthsList = [0.5, 2, 4]

    #Find the annual average temperature, which will be the temperature at very low depths.
    annualAvg = sum(groundtemp1st[8:])/12 ## [8:] denotes from 8th row in list onwards as in groundtemp1st,groundtemp2nd etc data starts in 8th row

    #Find the maximum deviation around this for get a scale for the horizontal axis.
    allValues = []
    allValues.extend(groundtemp1st[8:])
    allValues.extend(groundtemp2nd[8:])
    allValues.extend(groundtemp3rd[8:])
    
    print allValues

    allValues.sort()
    maxDiff = max(allValues) - annualAvg
    minDiff = annualAvg - min(allValues)

    if maxDiff > minDiff: diffFactor = maxDiff/4
    else: diffFactor = minDiff/4

    #Create the points for the temperature profile curves
    ptsList = []
    for count in range(12):
        pt1 = rc.Geometry.Point3d(rectangleCenterPt.X + (groundtemp1st[count+8]- annualAvg)/diffFactor, rectangleCenterPt.Y, rectangleCenterPt.Z-0.5)
        pt2 = rc.Geometry.Point3d(rectangleCenterPt.X + (groundtemp2nd[count+8]- annualAvg)/diffFactor, rectangleCenterPt.Y, rectangleCenterPt.Z-2)
        pt3 = rc.Geometry.Point3d(rectangleCenterPt.X + (groundtemp3rd[count+8]- annualAvg)/diffFactor, rectangleCenterPt.Y, rectangleCenterPt.Z-4)
        pt4 = rc.Geometry.Point3d(rectangleCenterPt.X, rectangleCenterPt.Y, rectangleCenterPt.Z-9)
        ptsList.append([pt1, pt2, pt3, pt4])

    #Create the ground profile curves.
    profileCrvs = []
    for list in ptsList:
        monthCrv = rc.Geometry.Curve.CreateInterpolatedCurve(list, 3)
        profileCrvs.append(monthCrv)

else: pass
